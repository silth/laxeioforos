<!doctype html>
<html lang="el">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Η τυχερή κλήρωση του 81ου Δημοτικού</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@400;600;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg0:#07070a;
      --bg1:#0e0f16;

      --text: rgba(255,255,255,.94);
      --muted: rgba(255,255,255,.62);

      --sidebarW: 22%;
      --mainW: 78%;

      --reelW: 190px;
      --reelH: 240px;
      --cellH: 210px;
      --radius: 28px;
      --gap: 20px;

      --ticketAccent: rgba(255, 214, 92, .95);
    }

    *{ box-sizing:border-box; }
    html, body { height:100%; }
    body{
      margin:0;
      background:
        radial-gradient(1200px 900px at 40% 18%, #1b1d2e 0%, transparent 55%),
        radial-gradient(1100px 900px at 70% 72%, #2b1432 0%, transparent 55%),
        radial-gradient(900px 700px at 20% 85%, #10313a 0%, transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      color:var(--text);
      font-family: "Roboto Slab", system-ui, serif;
      overflow:hidden;
    }

    .app{
      height:100vh;
      width:100vw;
      display:flex;
      gap:18px;
      padding:18px;
    }

    .main{
      width:var(--mainW);
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .sidebar{
      width:var(--sidebarW);
      min-width: 280px;
      max-width: 460px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .panel{
      border-radius:26px;
      background: linear-gradient(180deg, rgba(255,255,255,.11), rgba(255,255,255,.04));
      border:1px solid rgba(255,255,255,.16);
      box-shadow:
        0 22px 70px rgba(0,0,0,.60),
        inset 0 1px 0 rgba(255,255,255,.12);
      overflow:hidden;
    }

    .stage{
      width:min(980px, 100%);
      padding:26px 22px 20px;
      position:relative;
      isolation:isolate;
    }

    .stage::before{
      content:"";
      position:absolute;
      inset:-120px -120px -140px -120px;
      background:
        radial-gradient(560px 260px at 50% 50%, rgba(255,70,170,.22), transparent 60%),
        radial-gradient(520px 240px at 40% 46%, rgba(90,240,255,.18), transparent 60%),
        radial-gradient(520px 240px at 60% 46%, rgba(255,200,70,.16), transparent 60%);
      filter: blur(2px);
      z-index:-1;
      pointer-events:none;
    }

    .title{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:16px;
      margin-bottom:14px;
    }
    .title h1{
      margin:0;
      font-weight:800;
      letter-spacing:.03em;
      font-size: clamp(22px, 2.2vw, 32px);
    }
    .title .hint{
      color:var(--muted);
      font-weight:600;
      font-size:14px;
      letter-spacing:.02em;
      white-space:nowrap;
    }

    .machine-wrap{
      position:relative;
      border-radius:30px;
      padding:18px 16px 14px;
      background:
        radial-gradient(600px 240px at 50% 15%, rgba(255,255,255,.10), transparent 60%),
        linear-gradient(180deg, rgba(0,0,0,.42), rgba(0,0,0,.18));
      border: 1px solid rgba(255,255,255,.12);
      box-shadow:
        0 22px 60px rgba(0,0,0,.62),
        inset 0 1px 0 rgba(255,255,255,.10);
      overflow:hidden;
    }

    .marquee{
      position:absolute;
      inset:10px;
      border-radius:26px;
      pointer-events:none;
      border:1px solid rgba(255,255,255,.08);
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.08),
        0 0 0 1px rgba(0,0,0,.2);
      background:
        radial-gradient(circle at 12px 12px, rgba(255,230,160,.9) 0 2px, rgba(255,230,160,.12) 3px, transparent 6px) 0 0 / 26px 26px,
        radial-gradient(circle at 12px 12px, rgba(110,245,255,.85) 0 2px, rgba(110,245,255,.12) 3px, transparent 6px) 13px 13px / 26px 26px;
      opacity:.65;
      mix-blend-mode:screen;
      animation: twinkle 1.35s linear infinite;
    }
    @keyframes twinkle{
      0%{ filter: brightness(1) saturate(1.1); }
      50%{ filter: brightness(1.35) saturate(1.25); }
      100%{ filter: brightness(1) saturate(1.1); }
    }

    .machine{
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:var(--gap);
      padding:20px 10px 10px;
      border-radius:28px;
    }

    .reel{
      width:var(--reelW);
      height:var(--reelH);
      border-radius:var(--radius);
      position:relative;
      overflow:hidden;
      background:
        radial-gradient(140px 180px at 50% 20%, rgba(255,255,255,.16), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.14);
      box-shadow:
        0 18px 45px rgba(0,0,0,.60),
        inset 0 1px 0 rgba(255,255,255,.15),
        inset 0 -22px 50px rgba(0,0,0,.38);
    }

    .reel .rim{
      position:absolute;
      inset:0;
      border-radius:var(--radius);
      pointer-events:none;
      box-shadow:
        inset 0 0 0 2px rgba(255,215,120,.25),
        inset 0 0 22px rgba(255,170,70,.12);
      z-index:4;
    }

    .reel::before{
      content:"";
      position:absolute;
      inset:0;
      background:
        linear-gradient(180deg, rgba(0,0,0,.62), transparent 22%, transparent 78%, rgba(0,0,0,.62)),
        linear-gradient(90deg, rgba(0,0,0,.38), transparent 22%, transparent 78%, rgba(0,0,0,.38));
      pointer-events:none;
      z-index:3;
    }

    .reel::after{
      content:"";
      position:absolute;
      left:-40%;
      top:-30%;
      width:75%;
      height:170%;
      transform:rotate(18deg);
      background: linear-gradient(90deg, transparent, rgba(255,255,255,.12), transparent);
      opacity:.85;
      pointer-events:none;
      z-index:3;
      mix-blend-mode:screen;
      animation: sweep 3.2s ease-in-out infinite;
    }
    @keyframes sweep{
      0%, 55% { transform: translateX(0) rotate(18deg); opacity:.35; }
      70% { opacity:.85; }
      100% { transform: translateX(55%) rotate(18deg); opacity:.35; }
    }

    .strip{
      position:absolute;
      left:0;
      top:0;
      width:100%;
      will-change: transform, filter;
      transform: translate3d(0,0,0);
    }

    .cell{
      height:var(--cellH);
      display:grid;
      place-items:center;
      font-size: clamp(104px, 8.5vw, 140px);
      font-weight:800;
      letter-spacing:.02em;
      text-shadow:
        0 2px 0 rgba(0,0,0,.55),
        0 12px 22px rgba(0,0,0,.55);
      user-select:none;
    }

    /* vertical-only blur */
    .reel.spinning .strip{
      filter: url(#vblur) contrast(.96) saturate(1.06);
    }

    .smear{
      position:absolute;
      inset:0;
      background:
        repeating-linear-gradient(
          180deg,
          rgba(255,255,255,.04) 0px,
          rgba(255,255,255,.04) 6px,
          rgba(255,255,255,0) 12px,
          rgba(255,255,255,0) 18px
        );
      opacity:0;
      transition: opacity 120ms ease;
      mix-blend-mode: overlay;
      pointer-events:none;
      z-index:2;
    }
    .reel.spinning .smear{ opacity:.75; }

    .payline{
      position:absolute;
      left:12px;
      right:12px;
      top:50%;
      height:0;
      transform:translateY(-50%);
      pointer-events:none;
      z-index:5;
    }
    .payline::before{
      content:"";
      position:absolute;
      left:0; right:0;
      height:6px;
      transform:translateY(-50%);
      background: linear-gradient(90deg, transparent, rgba(255,255,255,.18), transparent);
    }
    .payline::after{
      content:"";
      position:absolute;
      left:0; right:0;
      height:2px;
      transform:translateY(-50%);
      background: linear-gradient(90deg, transparent, rgba(255,215,120,.55), transparent);
      box-shadow: 0 0 18px rgba(255,200,80,.35);
    }

    .flash{
      position:absolute;
      inset:0;
      border-radius:var(--radius);
      background: radial-gradient(180px 130px at 50% 45%, rgba(255,255,255,.20), transparent 65%);
      opacity:0;
      pointer-events:none;
      z-index:6;
    }
    .reel.flash-on .flash{ animation: flash 220ms ease-out; }
    @keyframes flash{
      from{ opacity:0; }
      30%{ opacity:1; }
      to{ opacity:0; }
    }

    .controls{
      margin-top:14px;
      display:flex;
      justify-content:center;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
    }

    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.10);
      color:var(--text);
      padding:12px 18px;
      border-radius:14px;
      font: 800 13px/1 "Roboto Slab", serif;
      letter-spacing:.02em;
      cursor:pointer;
      box-shadow: 0 10px 25px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.10);
      transition: transform 120ms ease, background 120ms ease, opacity 120ms ease;
      user-select:none;
    }
    button:hover{ transform: translateY(-1px); background: rgba(255,255,255,.14); }
    button:active{ transform: translateY(1px) scale(.99); }
    button:disabled{
      opacity:.55;
      cursor:not-allowed;
      transform:none;
    }

    .winnerDisplay{
      margin-top:14px;
      margin-bottom:10px;
      text-align:center;
      padding:14px 16px 16px;
      border-radius:22px;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
      opacity: 1;
      transform: translateY(0);
      transition: opacity 180ms ease, transform 180ms ease;
    }
    .winnerDisplay.hidden{
      opacity:0;
      transform: translateY(-6px);
      pointer-events:none;
    }
    .winnerPrizeTitle{
      font-weight:900;
      font-size: clamp(28px, 3.0vw, 46px);
      line-height:1.14;
      color: rgba(255,255,255,.97);
      margin: 0 auto;
      max-width: 860px;
      word-break: break-word;
      text-shadow:
        0 0 18px rgba(255,220,120,.22),
        0 0 42px rgba(255,120,220,.16),
        0 0 70px rgba(90,240,255,.12);
    }
    .winnerPrizeCompany{
      margin-top:14px;
      font-size: clamp(16px, 1.6vw, 22px);
      font-weight:800;
      color: rgba(255,255,255,.80);
      letter-spacing:.02em;
      word-break: break-word;
    }

    /* Sidebar */
    .sidebar .panel{ padding:14px 14px 12px; }
    .sidebar-header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .sidebar-header h2{
      margin:0;
      font-size:16px;
      font-weight:800;
      letter-spacing:.06em;
    }
    .meta{
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:6px;
      min-width: 120px;
    }
    .count, .prizeCount{
      color:var(--muted);
      font-weight:800;
      font-size:12px;
      letter-spacing:.02em;
    }

    .winners{
      display:flex;
      flex-direction:column;
      gap:10px;
      max-height: calc(100vh - 250px);
      overflow:auto;
      padding-right:4px;
    }
    .winner-card{
      border-radius:16px;
      padding:12px 12px 10px;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
    }

    .winner-card .line1{
      font-weight:900;
      font-size:13px;
      line-height:1.25;
      color: rgba(255,255,255,.92);
      display:-webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 2;
      overflow:hidden;
      word-break: break-word;
    }
    .winner-card .ticketTag{
      color: var(--ticketAccent);
      letter-spacing:.10em;
      text-shadow: 0 0 14px rgba(255,210,90,.18);
      white-space:nowrap;
    }

    .winner-card .company{
      margin-top:7px;
      font-size:12px;
      color: var(--muted);
      letter-spacing:.02em;
      word-break: break-word;
    }

    .sidebar-actions{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:10px;
    }
    .sidebar-actions button{
      width:100%;
      padding:11px 12px;
      font-size:12px;
      letter-spacing:.02em;
      text-align:center;
    }

    .notice{
      margin-top:10px;
      font-size:12px;
      color: var(--muted);
      letter-spacing:.02em;
      line-height:1.35;
    }

    .winners::-webkit-scrollbar{ width:10px; }
    .winners::-webkit-scrollbar-thumb{
      background: rgba(255,255,255,.12);
      border-radius:10px;
      border:2px solid rgba(0,0,0,.25);
    }

    @media (max-width: 980px){
      body{ overflow:auto; }
      .app{ flex-direction:column; height:auto; }
      .main{ width:100%; }
      .sidebar{ width:100%; max-width:none; min-width:0; }
      .winners{ max-height: 360px; }
    }
  </style>
</head>
<body>

  <!-- SVG filter for vertical-only blur -->
  <svg width="0" height="0" style="position:absolute">
    <filter id="vblur">
      <feGaussianBlur in="SourceGraphic" stdDeviation="0 2.4" />
    </filter>
  </svg>

  <div class="app">
    <!-- MAIN -->
    <div class="main">
      <div class="panel stage">
        <div class="title">
          <h1>Η τυχερή κλήρωση του 81ου Δημοτικού</h1>
          <div class="hint">Space / Enter = Κλήρωση</div>
        </div>

        <div class="machine-wrap">
          <div class="marquee"></div>

          <div class="machine">
            <div class="payline"></div>

            <div class="reel" id="reel0">
              <div class="smear"></div><div class="flash"></div><div class="rim"></div>
              <div class="strip"></div>
            </div>

            <div class="reel" id="reel1">
              <div class="smear"></div><div class="flash"></div><div class="rim"></div>
              <div class="strip"></div>
            </div>

            <div class="reel" id="reel2">
              <div class="smear"></div><div class="flash"></div><div class="rim"></div>
              <div class="strip"></div>
            </div>
          </div>
        </div>

        <div class="winnerDisplay hidden" id="winnerDisplay" aria-live="polite">
          <div class="winnerPrizeTitle" id="winnerPrizeTitle">—</div>
          <div class="winnerPrizeCompany" id="winnerPrizeCompany">—</div>
        </div>

        <div class="controls">
          <button id="pickBtn">Κλήρωση νικητή</button>
        </div>
      </div>
    </div>

    <!-- SIDEBAR -->
    <aside class="sidebar">
      <div class="panel">
        <div class="sidebar-header">
          <h2>Νικητές</h2>
          <div class="meta">
            <div class="count">Νικητές: <span id="count">0</span></div>
            <div class="prizeCount">Δώρα: <span id="prizeCount">0</span></div>
          </div>
        </div>

        <div class="winners" id="winnersList" aria-live="polite"></div>

        <div class="sidebar-actions">
          <button id="autoBtn">Αυτόματη κλήρωση</button>
          <button id="exportBtn">Εξαγωγή νικητών (CSV)</button>
          <button id="resetBtn">Επαναφορά</button>
        </div>

        <div class="notice" id="csvStatus">Φόρτωση δώρων…</div>
      </div>
    </aside>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>

  <script>
    // ============================================================
    // 1) SOLD TICKETS PER SERIES (EDIT THIS LAST-MINUTE)
    // Values are "how many tickets sold" in that series: 0..100.
    // Example: "Β":45 means only Β00..Β44 exist (45 tickets).
    // ============================================================
    const SOLD_TICKETS_BY_SERIES = {
      "Α": 100,
      "Β": 30,
      "Γ": 100,
      "Δ": 100,
      "Ε": 100,
      "Ζ": 100,
      "Η": 100,
      "Θ": 100,
      "Ι": 100,
      "Κ": 100
    };

    // ============================================================
    // CSV auto-load (GitHub Pages): keep prizes.csv next to index.html
    // ============================================================
    const PRIZES_CSV_URL = "./prizes.csv";

    // ------------------------------------------------------------
    // PRIZES DATA (populated from CSV)
    // We keep the original CSV headers + row order,
    // and store winner_ticket per prize row.
    // ------------------------------------------------------------
    let prizes = [];                 // [{title, company, row:[], winnerTicket:""}...]
    let csvHeaders = null;           // ["title","company",...]
    let titleIdx = -1;
    let companyIdx = -1;

    // fallback if CSV fails (kept tiny on purpose)
    const FALLBACK_PRIZES = [
      { title: "Δώρο (fallback)", company: "—", row: ["Δώρο (fallback)", "—"], winnerTicket: "" }
    ];

    // ------------------------------------------------------------
    // CONFIG
    // ------------------------------------------------------------
    const SYMBOLS_GREEK_10 = "ΑΒΓΔΕΖΗΘΙΚ".split("");
    const DIGITS = "0123456789".split("");

    const reels = [
      { el: document.querySelector("#reel0"), symbols: SYMBOLS_GREEK_10 },
      { el: document.querySelector("#reel1"), symbols: DIGITS },
      { el: document.querySelector("#reel2"), symbols: DIGITS },
    ];

    const cellH = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--cellH"));

    // reel strip repeat (keep high so both normal and fast mode have room)
    const STRIP_REPEAT = 22;
    const baseSpeedPx = 5200;
    const speedVariancePx = 450;

    // Normal vs Fast animation budgets
    const ANIM = {
      normal: { loops: 10, durationBase: 1550, stagger: 240, stopDelay: 950 },
      fast:   { loops:  6, durationBase: 820,  stagger: 120, stopDelay: 320 } // stays comfortably under 3s/prize
    };

    // ------------------------------------------------------------
    // STATE
    // ------------------------------------------------------------
    const usedTickets = new Set();
    const winners = []; // newest-first: {ticket, prizeIdx, drawnAtISO}
    let prizeIndex = 0;

    let spinning = false;
    let pickLocked = false;
    let autoRunning = false;

    // UI
    const pickBtn = document.querySelector("#pickBtn");
    const resetBtn = document.querySelector("#resetBtn");
    const exportBtn = document.querySelector("#exportBtn");
    const autoBtn = document.querySelector("#autoBtn");

    const winnersList = document.querySelector("#winnersList");
    const countEl = document.querySelector("#count");
    const prizeCountEl = document.querySelector("#prizeCount");
    const csvStatus = document.querySelector("#csvStatus");

    const winnerDisplay = document.querySelector("#winnerDisplay");
    const winnerPrizeTitleEl = document.querySelector("#winnerPrizeTitle");
    const winnerPrizeCompanyEl = document.querySelector("#winnerPrizeCompany");

    // ------------------------------------------------------------
    // SOLD TICKETS: derived helpers
    // ------------------------------------------------------------
    function clampInt(n, min, max){
      const x = Number.isFinite(n) ? Math.floor(n) : min;
      return Math.max(min, Math.min(max, x));
    }

    function getSeriesMax(letter){
      const v = SOLD_TICKETS_BY_SERIES?.[letter];
      return clampInt(v ?? 100, 0, 100);
    }

    function getTotalAvailableTickets(){
      return SYMBOLS_GREEK_10.reduce((sum, l) => sum + getSeriesMax(l), 0);
    }

    function buildWeightedSeries(){
      const items = [];
      for (const l of SYMBOLS_GREEK_10){
        const max = getSeriesMax(l);
        if (max > 0) items.push({ letter: l, weight: max });
      }
      return items;
    }

    // ------------------------------------------------------------
    // STRIPS
    // ------------------------------------------------------------
    function buildStrip(reel){
      const strip = reel.el.querySelector(".strip");
      strip.innerHTML = "";

      for (let r = 0; r < STRIP_REPEAT; r++){
        for (const s of reel.symbols){
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.textContent = s;
          strip.appendChild(cell);
        }
      }

      reel.strip = strip;
      reel.totalCells = reel.symbols.length * STRIP_REPEAT;
      reel.totalPx = reel.totalCells * cellH;
      reel.posPx = 0;
      reel.raf = null;
      reel.lastT = 0;
      reel.speedPx = baseSpeedPx + (Math.random() * speedVariancePx);
    }

    reels.forEach(buildStrip);

    function setTranslatePx(strip, yPx){
      strip.style.transform = `translate3d(0, ${-yPx}px, 0)`;
    }

    function symbolIndex(reel, symbol){
      const idx = reel.symbols.indexOf(symbol);
      if (idx < 0) throw new Error("Symbol not found: " + symbol);
      return idx;
    }

    function escapeHtml(s){
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    // ------------------------------------------------------------
    // MAIN DISPLAY
    // ------------------------------------------------------------
    function hideWinnerDisplay(){ winnerDisplay.classList.add("hidden"); }
    function showWinnerDisplay({ prizeTitle, company }){
      winnerPrizeTitleEl.textContent = prizeTitle || "—";
      winnerPrizeCompanyEl.textContent = company || "—";
      winnerDisplay.classList.remove("hidden");
    }

    // ------------------------------------------------------------
    // SPIN
    // ------------------------------------------------------------
    function startSpin(){
      spinning = true;
      reels.forEach((reel) => {
        reel.el.classList.add("spinning");
        reel.strip.style.transition = "none";
        reel.lastT = performance.now();

        const loop = (t) => {
          if (!spinning) return;
          const dt = Math.min(0.05, (t - reel.lastT) / 1000);
          reel.lastT = t;

          reel.posPx = (reel.posPx + reel.speedPx * dt) % reel.totalPx;
          setTranslatePx(reel.strip, reel.posPx);

          reel.raf = requestAnimationFrame(loop);
        };

        reel.raf = requestAnimationFrame(loop);
      });
    }

    function stopAndLand(finalSymbols, mode, onDone){
      const cfg = ANIM[mode] || ANIM.normal;

      spinning = false;
      reels.forEach(r => { if (r.raf) cancelAnimationFrame(r.raf); });

      reels.forEach(reel => {
        const currentCell = Math.floor(reel.posPx / cellH);
        reel.posPx = (currentCell * cellH) % reel.totalPx;
        setTranslatePx(reel.strip, reel.posPx);
      });

      reels.forEach((reel, i) => {
        const sym = finalSymbols[i];
        const symIdx = symbolIndex(reel, sym);

        const currentCell = Math.floor(reel.posPx / cellH);
        const currentWithin = currentCell % reel.symbols.length;

        let delta = symIdx - currentWithin;
        if (delta < 0) delta += reel.symbols.length;

        let travelCells = (cfg.loops + i * 2) * reel.symbols.length + delta;
        const maxTravelCells = reel.totalCells - reel.symbols.length - 1;
        travelCells = Math.min(travelCells, maxTravelCells);

        const targetCell = (currentCell + travelCells) % reel.totalCells;
        const targetPx = targetCell * cellH;

        const dur = cfg.durationBase + i * cfg.stagger + (Math.random() * 120);

        reel.strip.style.transition = `transform ${dur}ms cubic-bezier(.08,.82,.12,1)`;
        reel.el.classList.add("spinning");
        setTranslatePx(reel.strip, targetPx);

        const unblurAt = Math.max(150, dur - 260);
        setTimeout(() => reel.el.classList.remove("spinning"), unblurAt);

        setTimeout(() => {
          reel.posPx = targetPx % reel.totalPx;

          reel.el.classList.add("flash-on");

          reel.strip.style.transition = `transform 120ms ease-out`;
          setTranslatePx(reel.strip, reel.posPx - 10);

          setTimeout(() => {
            reel.strip.style.transition = `transform 140ms ease-in`;
            setTranslatePx(reel.strip, reel.posPx);
          }, 120);

          setTimeout(() => reel.el.classList.remove("flash-on"), 220);

          if (i === reels.length - 1 && typeof onDone === "function"){
            onDone();
          }
        }, dur);
      });
    }

    // ------------------------------------------------------------
    // CONFETTI
    // ------------------------------------------------------------
    function vegasConfetti(isFast){
      // keep fast mode lighter
      const myConfetti = confetti.create(undefined, { resize: true, useWorker: true });
      const end = Date.now() + (isFast ? 380 : 900);

      (function frame(){
        myConfetti({
          particleCount: isFast ? 2 : 4,
          startVelocity: isFast ? 44 : 55,
          spread: 80,
          ticks: isFast ? 170 : 220,
          origin: { x: Math.random()*0.2 + 0.4, y: 0.15 }
        });

        if (Date.now() < end) requestAnimationFrame(frame);
      })();

      if (!isFast){
        setTimeout(() => {
          myConfetti({
            particleCount: 160,
            startVelocity: 60,
            spread: 95,
            ticks: 280,
            origin: { x: 0.5, y: 0.25 }
          });
        }, 220);
      }
    }

    // ------------------------------------------------------------
    // WINNERS UI
    // ------------------------------------------------------------
    function renderWinners(){
      countEl.textContent = String(winners.length);
      prizeCountEl.textContent = String(prizes.length || 0);

      winnersList.innerHTML = winners.map(w => {
        const p = prizes[w.prizeIdx];
        const title = p?.title ?? "—";
        const company = p?.company ?? "—";
        return `
          <div class="winner-card">
            <div class="line1" title="${escapeHtml(w.ticket + ': ' + title)}">
              <span class="ticketTag">${escapeHtml(w.ticket)}</span><span>: </span><span>${escapeHtml(title)}</span>
            </div>
            <div class="company" title="${escapeHtml(company)}">${escapeHtml(company)}</div>
          </div>
        `;
      }).join("");
    }

    // ------------------------------------------------------------
    // PRIZES
    // ------------------------------------------------------------
    function getNextPrize(){
      if (!prizes.length || prizeIndex >= prizes.length) return null;
      const idx = prizeIndex;
      prizeIndex += 1;
      return { idx, prize: prizes[idx] };
    }

    // ------------------------------------------------------------
    // TICKETS (respect SOLD_TICKETS_BY_SERIES)
    // ------------------------------------------------------------
    function pad2(n){ return String(n).padStart(2, "0"); }
    function ticketFromParts(letter, d1, d2){ return `${letter}${d1}${d2}`; }
    function ticketFromLetterAndNum(letter, n){
      const two = pad2(n);
      return [letter, two[0], two[1]];
    }

    function pickWeightedSeries(seriesWeighted){
      const total = seriesWeighted.reduce((s, x) => s + x.weight, 0);
      if (total <= 0) return null;
      let r = Math.random() * total;
      for (const it of seriesWeighted){
        r -= it.weight;
        if (r <= 0) return it.letter;
      }
      return seriesWeighted[seriesWeighted.length - 1]?.letter ?? null;
    }

    function pickUniqueTicket(){
      const totalTickets = getTotalAvailableTickets();
      if (usedTickets.size >= totalTickets) return null;

      const seriesWeighted = buildWeightedSeries();
      if (!seriesWeighted.length) return null;

      // try random
      for (let tries = 0; tries < 2500; tries++){
        const letter = pickWeightedSeries(seriesWeighted);
        const max = getSeriesMax(letter);
        if (max <= 0) continue;

        const n = Math.floor(Math.random() * max);
        const parts = ticketFromLetterAndNum(letter, n);
        const t = ticketFromParts(parts[0], parts[1], parts[2]);

        if (!usedTickets.has(t)) return parts;
      }

      // deterministic fallback
      for (const it of seriesWeighted){
        const letter = it.letter;
        const max = getSeriesMax(letter);
        for (let n = 0; n < max; n++){
          const parts = ticketFromLetterAndNum(letter, n);
          const t = ticketFromParts(parts[0], parts[1], parts[2]);
          if (!usedTickets.has(t)) return parts;
        }
      }
      return null;
    }

    // ------------------------------------------------------------
    // PICK FLOW (single draw as Promise)
    // ------------------------------------------------------------
    function setAllEnabled(enabled){
      pickBtn.disabled = !enabled;
      exportBtn.disabled = !enabled;
      resetBtn.disabled = !enabled;
      autoBtn.disabled = !enabled;
    }

    function registerWinner(ticket, prizeIdx){
      usedTickets.add(ticket);

      // store winner against the prize row (for "export in original CSV order")
      prizes[prizeIdx].winnerTicket = ticket;

      winners.unshift({
        ticket,
        prizeIdx,
        drawnAtISO: new Date().toISOString()
      });

      renderWinners();
    }

    function pickOne({ mode = "normal" } = {}){
      return new Promise((resolve) => {
        if (pickLocked) return resolve({ ok:false, reason:"locked" });

        const totalTickets = getTotalAvailableTickets();
        if (usedTickets.size >= totalTickets){
          showWinnerDisplay({ prizeTitle: "Δεν υπάρχουν άλλα διαθέσιμα εισιτήρια.", company: "" });
          return resolve({ ok:false, reason:"no_tickets" });
        }

        const next = getNextPrize();
        if (!next){
          showWinnerDisplay({ prizeTitle: "Δεν υπάρχουν άλλα διαθέσιμα δώρα.", company: "" });
          return resolve({ ok:false, reason:"no_prizes" });
        }

        pickLocked = true;
        setAllEnabled(false);

        hideWinnerDisplay();
        startSpin();

        const finalParts = pickUniqueTicket();
        if (!finalParts){
          spinning = false;
          pickLocked = false;
          setAllEnabled(true);
          showWinnerDisplay({ prizeTitle: "Δεν υπάρχουν άλλα διαθέσιμα εισιτήρια.", company: "" });
          return resolve({ ok:false, reason:"no_tickets" });
        }

        const finalTicket = ticketFromParts(finalParts[0], finalParts[1], finalParts[2]);
        const p = next.prize;

        const cfg = ANIM[mode] || ANIM.normal;
        setTimeout(() => {
          stopAndLand(finalParts, mode, () => {
            registerWinner(finalTicket, next.idx);

            showWinnerDisplay({ prizeTitle: p.title, company: p.company });
            vegasConfetti(mode === "fast");

            pickLocked = false;
            setAllEnabled(true);
            resolve({ ok:true, ticket: finalTicket, prizeIdx: next.idx });
          });
        }, cfg.stopDelay);
      });
    }

    // ------------------------------------------------------------
    // 2) AUTO MODE
    // ------------------------------------------------------------
    async function runAutoDraw(){
      if (autoRunning || pickLocked) return;

      autoRunning = true;
      setAllEnabled(false);
      csvStatus.textContent = "Αυτόματη κλήρωση σε εξέλιξη…";

      try{
        // keep going until prizes or tickets run out
        while (true){
          const res = await pickOne({ mode: "fast" });
          if (!res.ok) break;

          // optional tiny pause so people can read (still keeps <3s total)
          await new Promise(r => setTimeout(r, 220));
        }
      } finally {
        autoRunning = false;
        setAllEnabled(true);

        const remainingPrizes = Math.max(0, (prizes?.length || 0) - prizeIndex);
        const remainingTickets = Math.max(0, getTotalAvailableTickets() - usedTickets.size);

        if (remainingPrizes === 0) csvStatus.innerHTML = "Ολοκληρώθηκαν όλα τα δώρα.";
        else if (remainingTickets === 0) csvStatus.innerHTML = "Τέλος εισιτηρίων πριν ολοκληρωθούν τα δώρα.";
        else csvStatus.innerHTML = "Η αυτόματη κλήρωση σταμάτησε.";
      }
    }

    // ------------------------------------------------------------
    // RESET
    // ------------------------------------------------------------
    function resetAll(){
      if (pickLocked || autoRunning) return;

      usedTickets.clear();
      winners.length = 0;
      prizeIndex = 0;

      // clear winner tickets on prize rows
      for (const p of prizes) p.winnerTicket = "";

      renderWinners();
      hideWinnerDisplay();
      csvStatus.textContent = prizes?.length ? `Έτοιμο. Φορτωμένα δώρα: ${prizes.length}.` : "Έτοιμο.";
    }

    // ------------------------------------------------------------
    // CSV parsing + auto-load (keeps original row order)
    // ------------------------------------------------------------
    function parseCSV(text){
      const rows = [];
      let row = [];
      let cur = "";
      let inQuotes = false;

      for (let i = 0; i < text.length; i++){
        const c = text[i];
        const next = text[i+1];

        if (inQuotes){
          if (c === '"' && next === '"'){ cur += '"'; i++; }
          else if (c === '"'){ inQuotes = false; }
          else { cur += c; }
        } else {
          if (c === '"'){ inQuotes = true; }
          else if (c === ","){ row.push(cur); cur = ""; }
          else if (c === "\n"){
            row.push(cur); cur = "";
            if (row.length === 1 && row[0].trim() === "") { row = []; continue; }
            rows.push(row.map(v => v.replace(/\r$/, "")));
            row = [];
          } else { cur += c; }
        }
      }
      row.push(cur);
      if (row.some(v => v.trim() !== "")) rows.push(row.map(v => v.replace(/\r$/, "")));
      return rows;
    }

    function normalizeKey(k){ return String(k || "").trim().toLowerCase(); }

    function guessColumns(headers){
      const h = headers.map(normalizeKey);
      const titleCandidates = ["title","prize","gift","δώρο","δωρο","name","prize_title","gift_title"];
      const companyCandidates = ["company","sponsor","provider","supplier","εταιρεία","εταιρεια","χορηγός","χορηγος"];

      const findIndex = (cands) => {
        for (const c of cands){
          const idx = h.indexOf(c);
          if (idx !== -1) return idx;
        }
        return -1;
      };

      return { titleIdx: findIndex(titleCandidates), companyIdx: findIndex(companyCandidates) };
    }

    function loadPrizesFromCSVText(text){
      const rows = parseCSV(text);
      if (rows.length < 2) throw new Error("CSV has no data rows.");

      csvHeaders = rows[0];
      const guessed = guessColumns(csvHeaders);
      titleIdx = guessed.titleIdx;
      companyIdx = guessed.companyIdx;

      if (titleIdx === -1) throw new Error("No title column found. Expected header 'title'.");

      const parsed = [];
      for (let r = 1; r < rows.length; r++){
        const row = rows[r];

        // pad row to header length so we can re-export consistently
        while (row.length < csvHeaders.length) row.push("");

        const title = (row[titleIdx] ?? "").trim();
        const company = (companyIdx !== -1 ? (row[companyIdx] ?? "").trim() : "").trim();

        if (!title) continue;

        parsed.push({
          title: title.slice(0, 200),
          company: (company.slice(0, 80) || "—"),
          row: row.slice(0, csvHeaders.length),
          winnerTicket: ""
        });
      }

      if (!parsed.length) throw new Error("No valid prizes parsed.");
      return parsed;
    }

    async function autoLoadCSV(){
      try{
        const res = await fetch(PRIZES_CSV_URL, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status} when fetching ${PRIZES_CSV_URL}`);
        const text = await res.text();

        prizes = loadPrizesFromCSVText(text);
        prizeIndex = 0;

        const totalTickets = getTotalAvailableTickets();
        csvStatus.innerHTML = `Φορτώθηκαν <b>${prizes.length}</b> δώρα. Διαθέσιμα εισιτήρια: <b>${totalTickets}</b>.`;
        renderWinners();
      } catch (err){
        console.error(err);
        prizes = FALLBACK_PRIZES.map(p => ({...p}));
        csvHeaders = ["title","company"];
        titleIdx = 0;
        companyIdx = 1;

        csvStatus.textContent = "Αποτυχία φόρτωσης prizes.csv. Έλεγξε ότι υπάρχει στο ίδιο folder με το index.html.";
        renderWinners();
      }
    }

    // ------------------------------------------------------------
    // 3) EXPORT: keep original CSV row order, add winner_ticket last column
    // ------------------------------------------------------------
    function toCSVCell(value){
      const s = String(value ?? "");
      if (/[",\n\r]/.test(s)) return `"${s.replaceAll('"','""')}"`;
      return s;
    }

    function exportWinnersCSV(){
      if (!prizes.length){
        csvStatus.textContent = "Δεν υπάρχουν δώρα για εξαγωγή.";
        return;
      }

      const headers = (csvHeaders && csvHeaders.length) ? csvHeaders.slice() : ["title","company"];
      const outHeader = [...headers, "winner_ticket"];
      const lines = [outHeader.map(toCSVCell).join(",")];

      for (const p of prizes){
        // prefer original row so we keep original order + any extra columns
        let row = Array.isArray(p.row) ? p.row.slice(0, headers.length) : [];

        // if no original row, reconstruct minimal
        if (row.length < headers.length){
          row = new Array(headers.length).fill("");
          if (titleIdx >= 0) row[titleIdx] = p.title ?? "";
          if (companyIdx >= 0) row[companyIdx] = p.company ?? "";
        }

        lines.push([...row, p.winnerTicket || ""].map(toCSVCell).join(","));
      }

      const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      const stamp = new Date().toISOString().slice(0,19).replaceAll(":","-");
      a.href = url;
      a.download = `prizes-with-winners-${stamp}.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();

      URL.revokeObjectURL(url);

      csvStatus.textContent = "Έγινε εξαγωγή CSV (σειρά όπως το αρχικό αρχείο, + winner_ticket).";
    }

    // ------------------------------------------------------------
    // EVENTS
    // ------------------------------------------------------------
    pickBtn.addEventListener("click", () => pickOne({ mode: "normal" }));
    autoBtn.addEventListener("click", runAutoDraw);
    resetBtn.addEventListener("click", resetAll);
    exportBtn.addEventListener("click", exportWinnersCSV);

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space" || e.code === "Enter") {
        e.preventDefault();
        pickOne({ mode: "normal" });
      }
      if (e.code === "Escape") {
        e.preventDefault();
        resetAll();
      }
    });

    // initial reel positions + initial render
    reels.forEach((reel, i) => {
      reel.posPx = (i * 3) * cellH;
      setTranslatePx(reel.strip, reel.posPx);
    });

    renderWinners();
    hideWinnerDisplay();

    // Auto-load prizes from CSV on startup
    autoLoadCSV();
  </script>
</body>
</html>
